\chapter{Аналитический раздел}

\section{Модель представления объектов сцены}

В данном разделе рассматривается структура и организация трёхмерной сцены, предназначенной для визуализации моделей материнских плат. Сцена служит основой для размещения и манипулирования компонентами материнских плат, а также предоставляет инструменты для наблюдения модели из различных ракурсов.

Сцена в программе представляет собой трехмерное пространство, в котором моделируются материнские платы и их компоненты. Пользователь имеет возможность вращать, перемещать, масштабировать и добавлять компоненты в сцену, что обеспечивает удобство в визуализации и детальном изучении различных аспектов конструкции.

\section{Типы материнских плат и их компоненты}

В программе предусмотрена поддержка трёх основных типов материнских плат: ATX, Micro-ATX и Mini-ITX. Для каждого типа материнской платы пользователь может визуализировать и модифицировать расположение следующих компонентов:
\begin{itemize}[label=---]
	\item процессор;
	\item видеокарты;
	\item модули оперативной памяти.
\end{itemize}

На рисунках \ref{img:atx}--\ref{img:gpu} представлены примеры форматов материнских плат и их компоненты.

\imgScale{0.7}{atx}{Формат ATX материнской платы}
\imgScale{0.5}{microatx}{Формат Micro-ATX материнской платы}
\imgScale{0.5}{miniitx}{Формат Mini-ITX материнской платы}
\imgScale{0.25}{cpu}{Процессор}
\imgScale{0.5}{ram}{Модуль оперативной памяти}
\imgScale{0.4}{gpu}{Модуль видеокарты}
\clearpage

Источник света --- точечный объект в пространстве на некотором расстоянии от сцены, расположение которого задается с помощью значений углов по осям $X$ и $Y$ относительно наблюдателя. Лучи света распространяются от источника параллельно в сторону сцены в некотором ограниченном секторе.

Имеется три варианта отображения объекта.
\begin{itemize}[label=---]
    \item \textit{Каркасная модель} --- задается информация о вершинах и рёбрах объектов. Это простейший вид моделей, так как задается минимум информации. Однако данный вид представления объектов не всегда корректно передает форму объекта.
    \item \textit{Поверхностная модель} ---  такая модель позволяет описывать и манипулировать поверхностями и кривыми на модели. Все поверхности могут быть аппроксимированы многогранниками. Недостаток данного вида модели заключается в том, что отсутствует информация, о том, с какой стороны поверхности находится материал.
    \item \textit{Твердотельная модель} --- помимо информации о поверхности добавляется информация о том, где расположен материал. Чаще всего это делают путём указания направления внутренней нормали.
\end{itemize}

В случае конструктора лучше всего использовать поверхностную модель, так как в данном случае не важно, из какого материала сделан элемент конструктора, а каркасная модель не всегда целиком передает форму объекта.

\section{Способ задания поверхности}
Существует несколько вариантов задания поверхностной модели.
\begin{itemize}[label=---]
    \item \textit{Аналитический способ} --- заключается в том, что для получения поверхности нужно дополнительно вычислять функцию, зависящую от параметра.
    \item \textit{Полигональная сетка} --- заключается в том, что информация о модели хранится в виде совокупности вершин, ребер и граней.
\end{itemize}

Из двух представленных вариантов наиболее оптимальным является использование полигональной сетки, так как такой вариант задания поверхности позволит более быстро выполнять операции над объектами.

\section{Способ хранения полигональной модели}

Далее необходимо выбрать, как именно хранить такую сетку. Существует несколько вариантов, как это можно реализовать.

\begin{itemize}[label=---]
    \item \textit{Вершинное представление} (хранится информация о вершинах, которые в свою очередь указывают на другие вершины, с которыми они соединены).
    \item \textit{Cписок граней} (объект представляется как множество граней и вершин, любая грань состоит минимум из трёх вершин).
    \item \textit{Таблица углов} (веер треугольников).
\end{itemize}

Для хранения полигональной сетки будет использоваться список граней.

\section{Алгоритмы построения изображения}

Для того, чтобы выбрать подходящий алгоритм построения изображения, необходимо осуществить краткий обзор известных алгоритмов и осуществить выбор наиболее подходящего для решения поставленной задачи.



\subsection{Алгоритм Робертса}
Алгоритм Робертса~\cite{math_cg} представляет собой первое известное решение задачи об удалении невидимых линий. Это алгоритм, использующий математическое решение, которое работает в объектном пространстве. Алгоритм сначала удаляет ребра или грани каждого тела, которые скрыты самим телом. Затем каждая оставшаяся грань каждого тела сравнивается с каждым из оставшихся тел, чтобы определить, какая часть или какие части, если таковые имеются, скрыты этими телами. Таким образом, вычислительные требования к алгоритму Робертса теоретически увеличиваются пропорционально квадрату количества объектов. Математические методы, используемые в алгоритме Робертса, просты, мощны и точны. Наконец, реализации, использующие предварительную сортировку по приоритету z и простые проверки на пересечение или минимаксные тесты, демонстрируют почти линейный рост в зависимости от количества объектов.

Таким образом, можно выделить следующий недостаток алгоритма: алгоритм требует, чтобы все объекты на сцене были выпуклыми, а вогнутые объекты должны быть подразделены на составляющие выпуклые тела. Кроме того, алгоритм характеризуется высокой вычислительной трудоемкостью, которая теоретически растет прямо пропорционально квадрату количества объектов на сцене.
В качестве преимущества можно отметить высокую точность вычислений.


\subsection{Алгоритм Варнока}
Основная идея алгоритма заключается в том, чтобы тратить меньше количества ресурсов и усилий на обработку тех участков сцены, которые содержат незначительное количество информации \cite{math_cg}. Подавляющее большинство времени и усилий уделяется участкам с высоким содержанием информации. Алгоритм Варнока использует тот факт, что большие области окна (экрана) похожи. Эта характеристика проявляется в том, что атрибуты пикселей (точек) как в горизонтальном ($x$), так и в вертикальном ($y$) направлениях обычно похожи. Алгоритм Уорнока рассматривает окно (или объект) и стремится определить, пусто ли оно, или содержание окна достаточно простое для его разрешения. Если нет, информация о содержании подокна, достаточно простая для определения, или размер подокна находится на пределе желаемого разрешения.
Данный алгоритм работает в пространстве изображений. В зависимости от расположения полигонов в сцене, окно может обрабатываться различными способами. Если все полигоны в сцене не пересекаются с окном, то окно считается пустым и отображается в фоновом цвете или интенсивности без дальнейшего разделения. В случае, когда в окне находится только один полигон, область за пределами полигона заполняется фоновой интенсивностью или цветом, а сам полигон - соответствующей интенсивностью или цветом. Если один полигон пересекает окно, то внешняя его часть заполняется фоновым цветом, а пересекаемая часть - цветом или интенсивностью полигона. Когда окно окружено одним полигоном и внутри него нет других полигонов, оно заполняется цветом или интенсивностью этого окружающего полигона. Если же вокруг окна обнаруживается более одного полигона, и ближайший к глазу полигон окружает окно, то окно также окрашивается в цвет этого полигона. Если ни один из этих критериев не выполняется, окно подлежит дальнейшему разделению. Эти условия определяют, как должно обрабатываться каждое окно в зависимости от взаимного расположения полигонов. Преимущество данного алгоритма заключается в его простоте.


\subsection{Алгоритм Вейлера-Азертона}
Алгоритм Вейлера-Азертона \cite{math_cg} стремится минимизировать количество разделений окна по сравнению с алгоритмом Варнока, производя разделение вдоль границ полигонов. Этот алгоритм, работающий в пространстве объектов с любой точностью, генерирует полигоны как конечный результат. Благодаря тому, что результат состоит из полных полигонов, алгоритм удобно применяют для создания видимых линий и устранения невидимых линий. Процесс визуализации поверхности включает несколько этапов: начинается с предварительной сортировки по глубине для установления приблизительного приоритета глубины. Затем следует сортировка по площади полигона, ориентированная на полигон, ближайший к точке наблюдения, и удаление полигонов, расположенных за этим ближайшим полигоном. В случае необходимости проводится рекурсивное подразделение и окончательная глубинная сортировка для устранения любых неоднозначностей. Предполагая, что точка наблюдения находится в бесконечности на положительной оси z, первым полигоном в списке становится тот, у которого вершина имеет наибольшую координату z. Первый полигон в предварительно отсортированном по глубине списке используется как полигон для первоначального отсечения, а остальные полигоны становятся объект-полигонами. Для обработки каждого объект-полигона применяется алгоритм отсечения Вейлера-Азертона, что включает управление списками внутренних и внешних полигонов.

\imgScale{0.5}{weiler-atherton}{Отсечение полигонов для алгоритма удаления невидимых поверхностей Вейлера-Азертона}

\subsection{Алгоритм определения видимых поверхностей путём трассировки лучей}
Основная идея данного алгоритма заключается в том, что наблюдатель видит объект за счёт света, исходящего от источника, который попадает на объект и затем достигает наблюдателя. Свет может достичь наблюдателя отражением от поверхности. Если провести трассировку световых лучей от источника, то очень мало из них достигнут зрителя. Следовательно, процесс вычислительно неэффективен. Таким образом было предложено проводить трассировку лучей в обратном направлении (от наблюдателя к объекту). Простая трассировка луча предствлена в рисунке \ref{img:raytracing}.

\imgScale{0.6}{raytracing}{Трассировка луча}
\FloatBarrier

Алгоритм предполагает, что сцена трансформирована в пространство изображения. Также разумевается, что наблюдатель находится в бесконечности, на положительной оси z, следовательно, все лучи света параллельны оси z. Каждый луч проходит от наблюдателя через центр пикселя на растре в сцену. Путь каждого луча отслеживается для определения, с какими объектами в сцене, если таковые имеются, он пересекается. Каждый объект в сцене должен быть исследован на каждом луче. Если луч пересекает объект, определяются все возможные точки пересечения луча и объекта. Этот процесс потенциально дает множественные пересечения для множества объектов. Пересечения сортируются по глубине. Пересечение объекта, ближайшего к наблюдателю, то есть с максимальным значением $z$, представляет видимую поверхность для этого пикселя. Атрибуты этого объекта используются для определения характеристик пикселя.

\subsection{Алгоритм, использующий z-буффер}

Z-буфер --- это отдельный буфер глубины, используемый для хранения координаты $z$ каждого видимого пикселя в пространстве изображений \cite{math_cg}. Алгоритм, использующий z-буфер является одним из самых простых алгоритмов удаления невидимых поверхностей. Данный алгоритм работает в пространстве изображения. В данном алгоритме, буфер кадра используется для заполнения атрибутов (интенсивности) каждого пикселя. При выполнении алгоритма, глубина (значение $z$) нового пикселя сравнивается с глубиной пикселя, уже записанного в буфер кадра. Если сравнение показывает, что новый пиксель находится ближе к зрителю, чем пиксель в буфере кадра, новый пиксель записывается в буфер кадра, а z-буфер обновляется новым значением $z$. Если нет, никаких действий не производится. Концептуально, алгоритм представляет собой поиск по ($x$, $y$) наибольшего значения $Z(x, y)$. Простота алгоритма является его главным преимуществом. Кроме того, рассматриваемый алгоритм позволяет решать проблему видимых поверхностей и отображать пересечения сложных поверхностей без затруднений.

Для каждого из $m\cdot n$ пикселей в буфере кадра размера $m\times n$ мы находим ближайший из $k$ полигонов. Исходя из данных соображений, получаем $nmk$ вычислений глубины. Таким образом временная сложность алгоритма --- O($nmk$). Вдобавок, время работы алгоритма практически не зависит от числа многоугольников, так как с увеличением их числа уменьшается размер, поэтому для каждого пикселя $k$ можно считать некоторой константой.

Преимущества алгоритма:
\begin{itemize}[label=---]
    \item относительно простая реализация;
    \item небольшая вычислительная трудоемкость;
    \item отсутствие сортировки объектов по параметру глубины, вследствие чего происходит экономия времени;
    \item возможность небольшой модификации алгоритма для работы с тенями.
\end{itemize}

Недостатки алгоритма:
\begin{itemize}[label=---]
    \item использование двух буферов, как следствие большое использование памяти;
    \item для работы с прозрачными объектами необходима модификация алгоритма.
\end{itemize}

\subsection{Выбор алгоритма построения теней}

При выборе алгоритма построения теней следует обратить внимание на простоту реализации алгоритма и время, необходимое для его написания. Если в качестве алгоритма удаления невидимых ребер и поверхностей использовать алгоритм обратной трассировки лучей, то тени уже будут построены в результате работы данного алгоритма (построение теней происходит во время выполнения алгоритма, т.к. пиксел затемняется в случае, когда испускаемый луч попадает на объект, но не попадает на источник света). Поскольку стало ясно, что алгоритм обратной трассировки использовать не следует, можно попробовать модифицировать алгоритм z-буфера путём добавления вычисления теневого буфера.

Благодаря такой модификации не потребуется писать много дополнительного кода (а лишь немного изменить уже написанный), да и модифицировать уже реализованный алгоритм удобнее, чем использовать что-то новое.

\subsection{Итоговый выбор алгоритмов}

Анализ изоженных алгоритмов показывает, что самой подходящей комбинацией будет z-буфер и его дальнейшая модификация для построения теней. Z-буфер выбран потому, что данный алгоритм достаточно устойчив к входным данным и оценка сложности позволяет рассчитывать на работу этого алгоритма в реальном времени, что является одним из основных требований к данной задаче.

\section{Выбор механизма размещения объектов}

Для обеспечения точного размещения компонентов на модели материнской платы в программе предусмотрен специализированный механизм, позволяющий пользователям манипулировать компонентами. Компоненты можно добавлять на материнскую плату в предопределённые места, соответствующие разъёмам для установки выбранного компонента (например, разъёмы для блоков оперативной памяти DDR4, PCIEX16 разъёмы для видеокарт, разъём для процессора). При попытке добавить новый компонент на уже занятое место, пользователь получает уведомление о том, что выбранный разъём занят.



